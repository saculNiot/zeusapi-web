{"ast":null,"code":"import { LocalStorage } from \"../../../utils/localStorage\";\nimport { Networking } from \"../../networking\";\nimport { Response } from \"../../response\";\nimport { GetUserByIdResponse, User } from \"../models/user_model\";\nexport class UserRepo {\n  constructor() {\n    this.networking = new Networking();\n  }\n\n  async createAccessToken(props) {\n    let headers = {\n      \"Content-Type\": \"application/json\"\n    };\n    console.log({\n      email: props.email,\n      password: props.password\n    });\n    let response = await this.networking.postData(\"api/token/\", // API choice is depends on the usage\n    {\n      email: props.email,\n      password: props.password\n    }, headers); // If data is retrieved and the data is not empty, then return\n\n    if (response.isSuccess && response.data !== null && response.data !== \"\") {\n      console.log(response.data[0].get(\"access\")); // await LocalStorage.setAccessToken(response.data.get(\"access\"));\n\n      return new Response(true, response.message, response.data); // If data is retrieved and the data is empty, then return\n    } else if (response.isSuccess && response.message === \"No records found\") {\n      return new Response(true, \"No records found\", \"\"); // If http method is timeout or being halt, then return\n    } else if (!response.isSuccess) {\n      return new Response(false, response.message, \"\");\n    } else {\n      return new Response(false, response.message, response.data);\n    }\n  }\n\n  async getUserById(value) {\n    const path = `userId=${value === null || value === void 0 ? void 0 : value.userId}`;\n    let response = await this.networking.getData(`get_user_by_id?${path}`); // If data is retrieved and the data is not empty, then return\n\n    if (response.isSuccess && response.data !== null && response.data !== \"\") {\n      let getUserByUserIdResponse = new GetUserByIdResponse().fromJson(response.data);\n      return new Response(true, response.message, getUserByUserIdResponse); // If data is retrieved and the data is empty, then return\n    } else if (response.isSuccess && response.message === \"No records found\") {\n      return new Response(true, \"No records found\", \"\"); // If http method is timeout or being halt, then return\n    } else if (!response.isSuccess) {\n      return new Response(false, response.message, \"\");\n    } else {\n      return new Response(false, response.message, response.data);\n    }\n  }\n\n  async saveUser(props) {\n    var _ref, _props$userId, _ref2, _props$email, _$nickname, _$packagePlan, _props$userId2, _props$email2, _props$nickname, _props$packagePlan, _props$userId3, _props$nickname2;\n\n    // Initialize the save user model\n    const saveUser = new User({\n      userId: props.userId,\n      email: props.email,\n      password: props.password,\n      nickname: props.nickname,\n      phoneNo: props.phoneNo,\n      acctType: props.acctType,\n      packagePlan: props.packagePlan,\n      orgName: props.orgName\n    }); // Object to Map, then to JSON\n\n    const body = Object.fromEntries(saveUser.toJson());\n    let headers = {\n      \"Content-Type\": \"application/json\"\n    };\n    let response = await this.networking.postData(props.purpose === \"login\" ? \"login_user\" : \"save_user\", // API choice is depends on the usage\n    body, headers); // If data is retrieved and the data is not empty, then return\n\n    if (response.isSuccess && response.data !== null && response.data !== \"\") {\n      switch (props.purpose) {\n        case \"login\":\n          // Login api will return the user data, so the if statement is to get the user data.\n          let getUserByUserIdResponse = null;\n\n          if (props.purpose === \"login\") {\n            getUserByUserIdResponse = new GetUserByIdResponse().fromJson(response.data);\n          } // Save the frequently access data in browser localstorage\n\n\n          LocalStorage.setUserID((_ref = (_props$userId = props.userId) !== null && _props$userId !== void 0 ? _props$userId : getUserByUserIdResponse[0].userId) !== null && _ref !== void 0 ? _ref : \"\");\n          LocalStorage.setEmail((_ref2 = (_props$email = props.email) !== null && _props$email !== void 0 ? _props$email : getUserByUserIdResponse[0].email) !== null && _ref2 !== void 0 ? _ref2 : \"\");\n          LocalStorage.setNickName((_$nickname = getUserByUserIdResponse[0].nickname) !== null && _$nickname !== void 0 ? _$nickname : \"\");\n          LocalStorage.setPackagePlan((_$packagePlan = getUserByUserIdResponse[0].packagePlan) !== null && _$packagePlan !== void 0 ? _$packagePlan : \"\");\n          break;\n\n        case \"new_user\":\n          // Save the frequently access data in browser localstorage\n          LocalStorage.setUserID((_props$userId2 = props.userId) !== null && _props$userId2 !== void 0 ? _props$userId2 : \"\");\n          LocalStorage.setEmail((_props$email2 = props.email) !== null && _props$email2 !== void 0 ? _props$email2 : \"\");\n          LocalStorage.setNickName((_props$nickname = props.nickname) !== null && _props$nickname !== void 0 ? _props$nickname : \"\");\n          LocalStorage.setPackagePlan((_props$packagePlan = props.packagePlan) !== null && _props$packagePlan !== void 0 ? _props$packagePlan : \"\");\n          break;\n\n        case \"update\":\n          LocalStorage.setUserID((_props$userId3 = props.userId) !== null && _props$userId3 !== void 0 ? _props$userId3 : \"\");\n          LocalStorage.setNickName((_props$nickname2 = props.nickname) !== null && _props$nickname2 !== void 0 ? _props$nickname2 : \"\");\n      }\n\n      return new Response(true, response.message, response.data); // If data is retrieved and the data is empty, then return\n    } else if (response.isSuccess && response.message === \"No records found\") {\n      return new Response(true, \"No records found\", \"\"); // If http method is timeout or being halt, then return\n    } else if (!response.isSuccess) {\n      return new Response(false, response.message, \"\");\n    } else {\n      return new Response(false, response.message, response.data);\n    }\n  }\n\n}","map":{"version":3,"sources":["/Users/gohshengyang/Documents/GitHub/zeusapi-web/src/services/api/repositories/user_repo.tsx"],"names":["LocalStorage","Networking","Response","GetUserByIdResponse","User","UserRepo","networking","createAccessToken","props","headers","console","log","email","password","response","postData","isSuccess","data","get","message","getUserById","value","path","userId","getData","getUserByUserIdResponse","fromJson","saveUser","nickname","phoneNo","acctType","packagePlan","orgName","body","Object","fromEntries","toJson","purpose","setUserID","setEmail","setNickName","setPackagePlan"],"mappings":"AAAA,SAASA,YAAT,QAA6B,6BAA7B;AACA,SAASC,UAAT,QAA2B,kBAA3B;AACA,SAASC,QAAT,QAAyB,gBAAzB;AACA,SAASC,mBAAT,EAA8BC,IAA9B,QAA0C,sBAA1C;AAEA,OAAO,MAAMC,QAAN,CAAe;AAAA;AAAA,SACrBC,UADqB,GACR,IAAIL,UAAJ,EADQ;AAAA;;AAGE,QAAjBM,iBAAiB,CAACC,KAAD,EAGD;AACrB,QAAIC,OAAO,GAAG;AACb,sBAAgB;AADH,KAAd;AAIAC,IAAAA,OAAO,CAACC,GAAR,CAAY;AAAEC,MAAAA,KAAK,EAAEJ,KAAK,CAACI,KAAf;AAAsBC,MAAAA,QAAQ,EAAEL,KAAK,CAACK;AAAtC,KAAZ;AAEA,QAAIC,QAAQ,GAAG,MAAM,KAAKR,UAAL,CAAgBS,QAAhB,CACpB,YADoB,EACN;AACd;AAAEH,MAAAA,KAAK,EAAEJ,KAAK,CAACI,KAAf;AAAsBC,MAAAA,QAAQ,EAAEL,KAAK,CAACK;AAAtC,KAFoB,EAGpBJ,OAHoB,CAArB,CAPqB,CAarB;;AACA,QACCK,QAAQ,CAACE,SAAT,IACAF,QAAQ,CAACG,IAAT,KAAkB,IADlB,IAEAH,QAAQ,CAACG,IAAT,KAAkB,EAHnB,EAIE;AACDP,MAAAA,OAAO,CAACC,GAAR,CAAYG,QAAQ,CAACG,IAAT,CAAc,CAAd,EAAiBC,GAAjB,CAAqB,QAArB,CAAZ,EADC,CAED;;AACA,aAAO,IAAIhB,QAAJ,CAAa,IAAb,EAAmBY,QAAQ,CAACK,OAA5B,EAAqCL,QAAQ,CAACG,IAA9C,CAAP,CAHC,CAKD;AACA,KAVD,MAUO,IACNH,QAAQ,CAACE,SAAT,IACAF,QAAQ,CAACK,OAAT,KAAqB,kBAFf,EAGL;AACD,aAAO,IAAIjB,QAAJ,CAAa,IAAb,EAAmB,kBAAnB,EAAuC,EAAvC,CAAP,CADC,CAGD;AACA,KAPM,MAOA,IAAI,CAACY,QAAQ,CAACE,SAAd,EAAyB;AAC/B,aAAO,IAAId,QAAJ,CAAa,KAAb,EAAoBY,QAAQ,CAACK,OAA7B,EAAsC,EAAtC,CAAP;AACA,KAFM,MAEA;AACN,aAAO,IAAIjB,QAAJ,CAAa,KAAb,EAAoBY,QAAQ,CAACK,OAA7B,EAAsCL,QAAQ,CAACG,IAA/C,CAAP;AACA;AACD;;AAEgB,QAAXG,WAAW,CAACC,KAAD,EAAgD;AAChE,UAAMC,IAAI,GAAI,UAASD,KAAV,aAAUA,KAAV,uBAAUA,KAAK,CAAEE,MAAO,EAArC;AACA,QAAIT,QAAQ,GAAG,MAAM,KAAKR,UAAL,CAAgBkB,OAAhB,CAAyB,kBAAiBF,IAAK,EAA/C,CAArB,CAFgE,CAGhE;;AACA,QACCR,QAAQ,CAACE,SAAT,IACAF,QAAQ,CAACG,IAAT,KAAkB,IADlB,IAEAH,QAAQ,CAACG,IAAT,KAAkB,EAHnB,EAIE;AACD,UAAIQ,uBAAuB,GAAG,IAAItB,mBAAJ,GAA0BuB,QAA1B,CAC7BZ,QAAQ,CAACG,IADoB,CAA9B;AAGA,aAAO,IAAIf,QAAJ,CACN,IADM,EAENY,QAAQ,CAACK,OAFH,EAGNM,uBAHM,CAAP,CAJC,CAUD;AACA,KAfD,MAeO,IACNX,QAAQ,CAACE,SAAT,IACAF,QAAQ,CAACK,OAAT,KAAqB,kBAFf,EAGL;AACD,aAAO,IAAIjB,QAAJ,CAAa,IAAb,EAAmB,kBAAnB,EAAuC,EAAvC,CAAP,CADC,CAGD;AACA,KAPM,MAOA,IAAI,CAACY,QAAQ,CAACE,SAAd,EAAyB;AAC/B,aAAO,IAAId,QAAJ,CAAa,KAAb,EAAoBY,QAAQ,CAACK,OAA7B,EAAsC,EAAtC,CAAP;AACA,KAFM,MAEA;AACN,aAAO,IAAIjB,QAAJ,CAAa,KAAb,EAAoBY,QAAQ,CAACK,OAA7B,EAAsCL,QAAQ,CAACG,IAA/C,CAAP;AACA;AACD;;AAEa,QAARU,QAAQ,CAACnB,KAAD,EAUQ;AAAA;;AACrB;AACA,UAAMmB,QAAQ,GAAG,IAAIvB,IAAJ,CAAS;AACzBmB,MAAAA,MAAM,EAAEf,KAAK,CAACe,MADW;AAEzBX,MAAAA,KAAK,EAAEJ,KAAK,CAACI,KAFY;AAGzBC,MAAAA,QAAQ,EAAEL,KAAK,CAACK,QAHS;AAIzBe,MAAAA,QAAQ,EAAEpB,KAAK,CAACoB,QAJS;AAKzBC,MAAAA,OAAO,EAAErB,KAAK,CAACqB,OALU;AAMzBC,MAAAA,QAAQ,EAAEtB,KAAK,CAACsB,QANS;AAOzBC,MAAAA,WAAW,EAAEvB,KAAK,CAACuB,WAPM;AAQzBC,MAAAA,OAAO,EAAExB,KAAK,CAACwB;AARU,KAAT,CAAjB,CAFqB,CAarB;;AACA,UAAMC,IAAI,GAAGC,MAAM,CAACC,WAAP,CAAmBR,QAAQ,CAACS,MAAT,EAAnB,CAAb;AAEA,QAAI3B,OAAO,GAAG;AACb,sBAAgB;AADH,KAAd;AAIA,QAAIK,QAAQ,GAAG,MAAM,KAAKR,UAAL,CAAgBS,QAAhB,CACpBP,KAAK,CAAC6B,OAAN,KAAkB,OAAlB,GAA4B,YAA5B,GAA2C,WADvB,EACoC;AACxDJ,IAAAA,IAFoB,EAGpBxB,OAHoB,CAArB,CApBqB,CA0BrB;;AACA,QACCK,QAAQ,CAACE,SAAT,IACAF,QAAQ,CAACG,IAAT,KAAkB,IADlB,IAEAH,QAAQ,CAACG,IAAT,KAAkB,EAHnB,EAIE;AACD,cAAQT,KAAK,CAAC6B,OAAd;AACC,aAAK,OAAL;AACC;AACA,cAAIZ,uBAAuB,GAAG,IAA9B;;AACA,cAAIjB,KAAK,CAAC6B,OAAN,KAAkB,OAAtB,EAA+B;AAC9BZ,YAAAA,uBAAuB,GACtB,IAAItB,mBAAJ,GAA0BuB,QAA1B,CAAmCZ,QAAQ,CAACG,IAA5C,CADD;AAEA,WANF,CAOC;;;AACAjB,UAAAA,YAAY,CAACsC,SAAb,0BACC9B,KAAK,CAACe,MADP,yDACiBE,uBAAuB,CAAE,CAAF,CAAvB,CAA4BF,MAD7C,uCACuD,EADvD;AAGAvB,UAAAA,YAAY,CAACuC,QAAb,0BACC/B,KAAK,CAACI,KADP,uDACgBa,uBAAuB,CAAE,CAAF,CAAvB,CAA4Bb,KAD5C,yCACqD,EADrD;AAGAZ,UAAAA,YAAY,CAACwC,WAAb,eACCf,uBAAuB,CAAE,CAAF,CAAvB,CAA4BG,QAD7B,mDACyC,EADzC;AAGA5B,UAAAA,YAAY,CAACyC,cAAb,kBACChB,uBAAuB,CAAE,CAAF,CAAvB,CAA4BM,WAD7B,yDAC4C,EAD5C;AAGA;;AACD,aAAK,UAAL;AACC;AACA/B,UAAAA,YAAY,CAACsC,SAAb,mBAAuB9B,KAAK,CAACe,MAA7B,2DAAuC,EAAvC;AACAvB,UAAAA,YAAY,CAACuC,QAAb,kBAAsB/B,KAAK,CAACI,KAA5B,yDAAqC,EAArC;AACAZ,UAAAA,YAAY,CAACwC,WAAb,oBAAyBhC,KAAK,CAACoB,QAA/B,6DAA2C,EAA3C;AACA5B,UAAAA,YAAY,CAACyC,cAAb,uBAA4BjC,KAAK,CAACuB,WAAlC,mEAAiD,EAAjD;AACA;;AACD,aAAK,QAAL;AACC/B,UAAAA,YAAY,CAACsC,SAAb,mBAAuB9B,KAAK,CAACe,MAA7B,2DAAuC,EAAvC;AACAvB,UAAAA,YAAY,CAACwC,WAAb,qBAAyBhC,KAAK,CAACoB,QAA/B,+DAA2C,EAA3C;AA/BF;;AAiCA,aAAO,IAAI1B,QAAJ,CAAa,IAAb,EAAmBY,QAAQ,CAACK,OAA5B,EAAqCL,QAAQ,CAACG,IAA9C,CAAP,CAlCC,CAoCD;AACA,KAzCD,MAyCO,IACNH,QAAQ,CAACE,SAAT,IACAF,QAAQ,CAACK,OAAT,KAAqB,kBAFf,EAGL;AACD,aAAO,IAAIjB,QAAJ,CAAa,IAAb,EAAmB,kBAAnB,EAAuC,EAAvC,CAAP,CADC,CAGD;AACA,KAPM,MAOA,IAAI,CAACY,QAAQ,CAACE,SAAd,EAAyB;AAC/B,aAAO,IAAId,QAAJ,CAAa,KAAb,EAAoBY,QAAQ,CAACK,OAA7B,EAAsC,EAAtC,CAAP;AACA,KAFM,MAEA;AACN,aAAO,IAAIjB,QAAJ,CAAa,KAAb,EAAoBY,QAAQ,CAACK,OAA7B,EAAsCL,QAAQ,CAACG,IAA/C,CAAP;AACA;AACD;;AAvKoB","sourcesContent":["import { LocalStorage } from \"../../../utils/localStorage\";\nimport { Networking } from \"../../networking\";\nimport { Response } from \"../../response\";\nimport { GetUserByIdResponse, User } from \"../models/user_model\";\n\nexport class UserRepo {\n\tnetworking = new Networking();\n\n\tasync createAccessToken(props: {\n\t\temail: string;\n\t\tpassword: string;\n\t}): Promise<Response> {\n\t\tlet headers = {\n\t\t\t\"Content-Type\": \"application/json\",\n\t\t};\n\n\t\tconsole.log({ email: props.email, password: props.password })\n\n\t\tlet response = await this.networking.postData(\n\t\t\t\"api/token/\", // API choice is depends on the usage\n\t\t\t{ email: props.email, password: props.password },\n\t\t\theaders\n\t\t);\n\n\t\t// If data is retrieved and the data is not empty, then return\n\t\tif (\n\t\t\tresponse.isSuccess &&\n\t\t\tresponse.data !== null &&\n\t\t\tresponse.data !== \"\"\n\t\t) {\n\t\t\tconsole.log(response.data[0].get(\"access\"));\n\t\t\t// await LocalStorage.setAccessToken(response.data.get(\"access\"));\n\t\t\treturn new Response(true, response.message, response.data);\n\n\t\t\t// If data is retrieved and the data is empty, then return\n\t\t} else if (\n\t\t\tresponse.isSuccess &&\n\t\t\tresponse.message === \"No records found\"\n\t\t) {\n\t\t\treturn new Response(true, \"No records found\", \"\");\n\n\t\t\t// If http method is timeout or being halt, then return\n\t\t} else if (!response.isSuccess) {\n\t\t\treturn new Response(false, response.message, \"\");\n\t\t} else {\n\t\t\treturn new Response(false, response.message, response.data);\n\t\t}\n\t}\n\n\tasync getUserById(value?: { userId: string }): Promise<Response> {\n\t\tconst path = `userId=${value?.userId}`;\n\t\tlet response = await this.networking.getData(`get_user_by_id?${path}`);\n\t\t// If data is retrieved and the data is not empty, then return\n\t\tif (\n\t\t\tresponse.isSuccess &&\n\t\t\tresponse.data !== null &&\n\t\t\tresponse.data !== \"\"\n\t\t) {\n\t\t\tlet getUserByUserIdResponse = new GetUserByIdResponse().fromJson(\n\t\t\t\tresponse.data\n\t\t\t);\n\t\t\treturn new Response(\n\t\t\t\ttrue,\n\t\t\t\tresponse.message,\n\t\t\t\tgetUserByUserIdResponse\n\t\t\t);\n\n\t\t\t// If data is retrieved and the data is empty, then return\n\t\t} else if (\n\t\t\tresponse.isSuccess &&\n\t\t\tresponse.message === \"No records found\"\n\t\t) {\n\t\t\treturn new Response(true, \"No records found\", \"\");\n\n\t\t\t// If http method is timeout or being halt, then return\n\t\t} else if (!response.isSuccess) {\n\t\t\treturn new Response(false, response.message, \"\");\n\t\t} else {\n\t\t\treturn new Response(false, response.message, response.data);\n\t\t}\n\t}\n\n\tasync saveUser(props: {\n\t\tpurpose: string; // To identify the usage of this method. Exp: login, update, new_user\n\t\tuserId?: string;\n\t\temail?: string;\n\t\tpassword?: string;\n\t\tnickname?: string;\n\t\tphoneNo?: string;\n\t\tacctType?: string;\n\t\torgName?: string;\n\t\tpackagePlan?: string;\n\t}): Promise<Response> {\n\t\t// Initialize the save user model\n\t\tconst saveUser = new User({\n\t\t\tuserId: props.userId,\n\t\t\temail: props.email,\n\t\t\tpassword: props.password,\n\t\t\tnickname: props.nickname,\n\t\t\tphoneNo: props.phoneNo,\n\t\t\tacctType: props.acctType,\n\t\t\tpackagePlan: props.packagePlan,\n\t\t\torgName: props.orgName,\n\t\t});\n\n\t\t// Object to Map, then to JSON\n\t\tconst body = Object.fromEntries(saveUser.toJson());\n\n\t\tlet headers = {\n\t\t\t\"Content-Type\": \"application/json\",\n\t\t};\n\n\t\tlet response = await this.networking.postData(\n\t\t\tprops.purpose === \"login\" ? \"login_user\" : \"save_user\", // API choice is depends on the usage\n\t\t\tbody,\n\t\t\theaders\n\t\t);\n\n\t\t// If data is retrieved and the data is not empty, then return\n\t\tif (\n\t\t\tresponse.isSuccess &&\n\t\t\tresponse.data !== null &&\n\t\t\tresponse.data !== \"\"\n\t\t) {\n\t\t\tswitch (props.purpose) {\n\t\t\t\tcase \"login\":\n\t\t\t\t\t// Login api will return the user data, so the if statement is to get the user data.\n\t\t\t\t\tlet getUserByUserIdResponse = null;\n\t\t\t\t\tif (props.purpose === \"login\") {\n\t\t\t\t\t\tgetUserByUserIdResponse =\n\t\t\t\t\t\t\tnew GetUserByIdResponse().fromJson(response.data);\n\t\t\t\t\t}\n\t\t\t\t\t// Save the frequently access data in browser localstorage\n\t\t\t\t\tLocalStorage.setUserID(\n\t\t\t\t\t\tprops.userId ?? getUserByUserIdResponse![0].userId ?? \"\"\n\t\t\t\t\t);\n\t\t\t\t\tLocalStorage.setEmail(\n\t\t\t\t\t\tprops.email ?? getUserByUserIdResponse![0].email ?? \"\"\n\t\t\t\t\t);\n\t\t\t\t\tLocalStorage.setNickName(\n\t\t\t\t\t\tgetUserByUserIdResponse![0].nickname ?? \"\"\n\t\t\t\t\t);\n\t\t\t\t\tLocalStorage.setPackagePlan(\n\t\t\t\t\t\tgetUserByUserIdResponse![0].packagePlan ?? \"\"\n\t\t\t\t\t);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"new_user\":\n\t\t\t\t\t// Save the frequently access data in browser localstorage\n\t\t\t\t\tLocalStorage.setUserID(props.userId ?? \"\");\n\t\t\t\t\tLocalStorage.setEmail(props.email ?? \"\");\n\t\t\t\t\tLocalStorage.setNickName(props.nickname ?? \"\");\n\t\t\t\t\tLocalStorage.setPackagePlan(props.packagePlan ?? \"\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"update\":\n\t\t\t\t\tLocalStorage.setUserID(props.userId ?? \"\");\n\t\t\t\t\tLocalStorage.setNickName(props.nickname ?? \"\");\n\t\t\t}\n\t\t\treturn new Response(true, response.message, response.data);\n\n\t\t\t// If data is retrieved and the data is empty, then return\n\t\t} else if (\n\t\t\tresponse.isSuccess &&\n\t\t\tresponse.message === \"No records found\"\n\t\t) {\n\t\t\treturn new Response(true, \"No records found\", \"\");\n\n\t\t\t// If http method is timeout or being halt, then return\n\t\t} else if (!response.isSuccess) {\n\t\t\treturn new Response(false, response.message, \"\");\n\t\t} else {\n\t\t\treturn new Response(false, response.message, response.data);\n\t\t}\n\t}\n}\n"]},"metadata":{},"sourceType":"module"}