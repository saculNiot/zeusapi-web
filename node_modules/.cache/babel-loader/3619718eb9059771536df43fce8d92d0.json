{"ast":null,"code":"import { Networking } from \"../../networking\";\nimport { Response } from \"../../response\";\nimport { DataRows, GetConfigParamResponse, GetDataRowsResponse, GetSchemaFieldResponse, GetUserUrlResponse, Graphs, SchemaField, UserUrl } from \"../models/url_model\";\nexport class UrlRepo {\n  constructor() {\n    this.networking = new Networking();\n  }\n\n  async getAllUserUrlByUserId(value) {\n    const path = `userId=${value === null || value === void 0 ? void 0 : value.userId}`;\n    let response = await this.networking.getData(`get_all_url_by_user_id?${path}`); // If data is retrieved and the data is not empty, then return\n\n    if (response.isSuccess && response.data !== null && response.data !== \"\") {\n      let getUserUrlResponse = new GetUserUrlResponse().fromJson(response.data);\n      return new Response(true, response.message, getUserUrlResponse); // If data is retrieved and the data is empty, then return\n    } else if (response.isSuccess && response.message === \"No records found\") {\n      return new Response(true, \"No records found\", \"\"); // If http method is timeout or being halt, then return\n    } else if (!response.isSuccess) {\n      return new Response(false, response.message, \"\");\n    } else {\n      return new Response(false, response.message, response.data);\n    }\n  }\n\n  async getUrlById(value) {\n    const path = `urlId=${value === null || value === void 0 ? void 0 : value.urlId}`;\n    let response = await this.networking.getData(`get_url_by_id?${path}`); // If data is retrieved and the data is not empty, then return\n\n    if (response.isSuccess && response.data !== null && response.data !== \"\") {\n      let getUserUrlResponse = new GetUserUrlResponse().fromJson(response.data);\n      return new Response(true, response.message, getUserUrlResponse); // If data is retrieved and the data is empty, then return\n    } else if (response.isSuccess && response.message === \"No records found\") {\n      return new Response(true, \"No records found\", \"\"); // If http method is timeout or being halt, then return\n    } else if (!response.isSuccess) {\n      return new Response(false, response.message, \"\");\n    } else {\n      return new Response(false, response.message, response.data);\n    }\n  }\n\n  async getUrlByApiKey(value) {\n    const path = `apiKey=${value === null || value === void 0 ? void 0 : value.apiKey}`;\n    let response = await this.networking.getData(`get_url_by_api_key?${path}`); // If data is retrieved and the data is not empty, then return\n\n    if (response.isSuccess && response.data !== null && response.data !== \"\") {\n      let getUserUrlResponse = new GetUserUrlResponse().fromJson(response.data);\n      return new Response(true, response.message, getUserUrlResponse); // If data is retrieved and the data is empty, then return\n    } else if (response.isSuccess && response.message === \"No records found\") {\n      return new Response(true, \"No records found\", \"\"); // If http method is timeout or being halt, then return\n    } else if (!response.isSuccess) {\n      return new Response(false, response.message, \"\");\n    } else {\n      return new Response(false, response.message, response.data);\n    }\n  }\n\n  async saveUrl(props) {\n    // Initialize the save user model\n    const save_url = new UserUrl({\n      userId: props.userId,\n      apiKey: props.apiKey,\n      url: props.url,\n      schema: props.schema,\n      configParam: props.configParam\n    }); // Object to Map, then to JSON\n\n    const body = Object.fromEntries(save_url.toJson());\n    let headers = {\n      \"Content-Type\": \"application/json\"\n    };\n    let response = await this.networking.postData(\"save_url\", // API choice is depends on the usage\n    body, headers); // If data is retrieved and the data is not empty, then return\n\n    if (response.isSuccess && response.data !== null && response.data !== \"\") {\n      return new Response(true, response.message, response.data); // If data is retrieved and the data is empty, then return\n    } else if (response.isSuccess && response.message === \"No records found\") {\n      return new Response(true, \"No records found\", \"\"); // If http method is timeout or being halt, then return\n    } else if (!response.isSuccess) {\n      return new Response(false, response.message, \"\");\n    } else {\n      return new Response(false, response.message, response.data);\n    }\n  }\n\n  async deleteUrl(props) {\n    // Initialize the save user model\n    const delete_url = new UserUrl({\n      urlId: props.urlId\n    }); // Object to Map, then to JSON\n\n    const body = Object.fromEntries(delete_url.toJson());\n    let response = await this.networking.deleteData(\"delete_url\", // API choice is depends on the usage\n    body); // If data is retrieved and the data is not empty, then return\n\n    if (response.isSuccess && response.data !== null && response.data !== \"\") {\n      return new Response(true, response.message, response.data); // If data is retrieved and the data is empty, then return\n    } else if (response.isSuccess && response.message === \"No records found\") {\n      return new Response(true, \"No records found\", \"\"); // If http method is timeout or being halt, then return\n    } else if (!response.isSuccess) {\n      return new Response(false, response.message, \"\");\n    } else {\n      return new Response(false, response.message, response.data);\n    }\n  }\n\n  async validateUrl(props) {\n    // Initialize the save user model\n    const validate_url = new SchemaField({\n      url: props.url\n    }); // Object to Map, then to JSON\n\n    const body = Object.fromEntries(validate_url.toJson());\n    let headers = {\n      \"Content-Type\": \"application/json\"\n    };\n    let response = await this.networking.postData(\"validate_url\", // API choice is depends on the usage\n    body, headers); // If data is retrieved and the data is not empty, then return\n\n    if (response.isSuccess && response.data !== null && response.data !== \"\") {\n      let getSchemaFieldResponse = new GetSchemaFieldResponse().fromJson(response.data);\n      return new Response(true, response.message, getSchemaFieldResponse); // If data is retrieved and the data is empty, then return\n    } else if (response.isSuccess && response.message === \"No records found\") {\n      return new Response(true, \"No records found\", \"\"); // If http method is timeout or being halt, then return\n    } else if (!response.isSuccess) {\n      return new Response(false, response.message, \"\");\n    } else {\n      return new Response(false, response.message, response.data);\n    }\n  }\n\n  async getSchemaByApiKey(value) {\n    const path = `apiKey=${value === null || value === void 0 ? void 0 : value.apiKey}`;\n    let response = await this.networking.getData(`get_schema_field?${path}`); // If data is retrieved and the data is not empty, then return\n\n    if (response.isSuccess && response.data !== null && response.data !== \"\") {\n      let getSchemaFieldResponse = new GetSchemaFieldResponse().fromJson(response.data);\n      return new Response(true, response.message, getSchemaFieldResponse); // If data is retrieved and the data is empty, then return\n    } else if (response.isSuccess && response.message === \"No records found\") {\n      return new Response(true, \"No records found\", \"\"); // If http method is timeout or being halt, then return\n    } else if (!response.isSuccess) {\n      return new Response(false, response.message, \"\");\n    } else {\n      return new Response(false, response.message, response.data);\n    }\n  }\n\n  async getConfigParamByApiKey(value) {\n    const path = `apiKey=${value === null || value === void 0 ? void 0 : value.apiKey}`;\n    let response = await this.networking.getData(`get_config_param_by_api_key?${path}`); // If data is retrieved and the data is not empty, then return\n\n    if (response.isSuccess && response.data !== null && response.data !== \"\") {\n      let getConfigParamResponse = new GetConfigParamResponse().fromJson(response.data);\n      return new Response(true, response.message, getConfigParamResponse); // If data is retrieved and the data is empty, then return\n    } else if (response.isSuccess && response.message === \"No records found\") {\n      return new Response(true, \"No records found\", \"\"); // If http method is timeout or being halt, then return\n    } else if (!response.isSuccess) {\n      return new Response(false, response.message, \"\");\n    } else {\n      return new Response(false, response.message, response.data);\n    }\n  }\n\n  async getDataRowsByApiKey(value) {\n    const path = `userApiId=${value === null || value === void 0 ? void 0 : value.userApiId}&apiKey=${value === null || value === void 0 ? void 0 : value.apiKey}&dimensionArray=${JSON.stringify(value === null || value === void 0 ? void 0 : value.dimensionArray)}&metricsArray=${JSON.stringify(value === null || value === void 0 ? void 0 : value.metricsArray)}`;\n    let response = await this.networking.getData(`generate_data?${path}`); // If data is retrieved and the data is not empty, then return\n\n    if (response.isSuccess && response.data !== null && response.data !== \"\") {\n      let getDataRowsByApiKey = new GetDataRowsResponse().fromJson(response.data);\n      return new Response(true, response.message, getDataRowsByApiKey); // If data is retrieved and the data is empty, then return\n    } else if (response.isSuccess && response.message === \"No records found\") {\n      return new Response(true, \"No records found\", \"\"); // If http method is timeout or being halt, then return\n    } else if (!response.isSuccess) {\n      return new Response(false, response.message, \"\");\n    } else {\n      return new Response(false, response.message, response.data);\n    }\n  }\n\n  async generateDataResponse(props) {\n    // Initialize the save user model\n    const generate_data = new DataRows({\n      userApiId: props.userApiId,\n      apiKey: props.apiKey,\n      dimensionArray: props.dimensionArray,\n      metricsArray: props.metricsArray,\n      metricsOperation: props.metricsOperation\n    }); // Object to Map, then to JSON\n\n    const body = Object.fromEntries(generate_data.toJson());\n    let headers = {\n      \"Content-Type\": \"application/json\"\n    };\n    let response = await this.networking.postData(\"generate_data\", // API choice is depends on the usage\n    body, headers); // If data is retrieved and the data is not empty, then return\n\n    if (response.isSuccess && response.data !== null && response.data !== \"\") {\n      let getSchemaFieldResponse = new GetDataRowsResponse().fromJson(response.data);\n      return new Response(true, response.message, getSchemaFieldResponse); // If data is retrieved and the data is empty, then return\n    } else if (response.isSuccess && response.message === \"No records found\") {\n      return new Response(true, \"No records found\", \"\"); // If http method is timeout or being halt, then return\n    } else if (!response.isSuccess) {\n      return new Response(false, response.message, \"\");\n    } else {\n      return new Response(false, response.message, response.data);\n    }\n  }\n\n  async saveGraph(props) {\n    // Initialize the save user model\n    const save_graph = new Graphs({\n      userApiId: props.userApiId,\n      apiKey: props.apiKey,\n      layouts: props.layouts,\n      graphs: props.graphs\n    }); // Object to Map, then to JSON\n\n    const body = Object.fromEntries(save_graph.toJson());\n    let headers = {\n      \"Content-Type\": \"application/json\"\n    };\n    let response = await this.networking.postData(\"save_graph\", // API choice is depends on the usage\n    body, headers); // If data is retrieved and the data is not empty, then return\n\n    if (response.isSuccess && response.data !== null && response.data !== \"\") {\n      return new Response(true, response.message, true); // If data is retrieved and the data is empty, then return\n    } else if (response.isSuccess && response.message === \"No records found\") {\n      return new Response(true, \"No records found\", \"\"); // If http method is timeout or being halt, then return\n    } else if (!response.isSuccess) {\n      return new Response(false, response.message, \"\");\n    } else {\n      return new Response(false, response.message, response.data);\n    }\n  }\n\n  async getGraphsByApiKey(value) {\n    const path = `apiKey=${value === null || value === void 0 ? void 0 : value.apiKey}`;\n    let response = await this.networking.getData(`get_graph_by_api_key?${path}`); // If data is retrieved and the data is not empty, then return\n\n    if (response.isSuccess && response.data !== null && response.data !== \"\") {\n      let getDataRowsByApiKey = new GetDataRowsResponse().fromJson(response.data);\n      return new Response(true, response.message, getDataRowsByApiKey); // If data is retrieved and the data is empty, then return\n    } else if (response.isSuccess && response.message === \"No records found\") {\n      return new Response(true, \"No records found\", \"\"); // If http method is timeout or being halt, then return\n    } else if (!response.isSuccess) {\n      return new Response(false, response.message, \"\");\n    } else {\n      return new Response(false, response.message, response.data);\n    }\n  }\n\n  async getGraphsWithParamByApiKey(value) {\n    const path = `apiKey=${value === null || value === void 0 ? void 0 : value.apiKey}`;\n    let response = await this.networking.getData(`get_graph_with_param_by_api_key?${path}`); // If data is retrieved and the data is not empty, then return\n\n    if (response.isSuccess && response.data !== null && response.data !== \"\") {\n      let getDataRowsByApiKey = new GetDataRowsResponse().fromJson(response.data);\n      return new Response(true, response.message, getDataRowsByApiKey); // If data is retrieved and the data is empty, then return\n    } else if (response.isSuccess && response.message === \"No records found\") {\n      return new Response(true, \"No records found\", \"\"); // If http method is timeout or being halt, then return\n    } else if (!response.isSuccess) {\n      return new Response(false, response.message, \"\");\n    } else {\n      return new Response(false, response.message, response.data);\n    }\n  }\n\n}","map":{"version":3,"sources":["/Users/gohshengyang/Documents/GitHub/codagence-web/src/services/api/repositories/url_repo.tsx"],"names":["Networking","Response","DataRows","GetConfigParamResponse","GetDataRowsResponse","GetSchemaFieldResponse","GetUserUrlResponse","Graphs","SchemaField","UserUrl","UrlRepo","networking","getAllUserUrlByUserId","value","path","userId","response","getData","isSuccess","data","getUserUrlResponse","fromJson","message","getUrlById","urlId","getUrlByApiKey","apiKey","saveUrl","props","save_url","url","schema","configParam","body","Object","fromEntries","toJson","headers","postData","deleteUrl","delete_url","deleteData","validateUrl","validate_url","getSchemaFieldResponse","getSchemaByApiKey","getConfigParamByApiKey","getConfigParamResponse","getDataRowsByApiKey","userApiId","JSON","stringify","dimensionArray","metricsArray","generateDataResponse","generate_data","metricsOperation","saveGraph","save_graph","layouts","graphs","getGraphsByApiKey","getGraphsWithParamByApiKey"],"mappings":"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","sourcesContent":["import { url } from \"inspector\";\nimport { Networking } from \"../../networking\";\nimport { Response } from \"../../response\";\nimport {\n\tConfigParam,\n\tDataRows,\n\tGetConfigParamResponse,\n\tGetDataRowsResponse,\n\tGetSchemaFieldResponse,\n\tGetUserUrlResponse,\n\tGraphs,\n\tSchemaField,\n\tUserUrl,\n} from \"../models/url_model\";\n\nexport class UrlRepo {\n\tnetworking = new Networking();\n\n\tasync getAllUserUrlByUserId(value?: { userId: string }): Promise<Response> {\n\t\tconst path = `userId=${value?.userId}`;\n\t\tlet response = await this.networking.getData(\n\t\t\t`get_all_url_by_user_id?${path}`\n\t\t);\n\t\t// If data is retrieved and the data is not empty, then return\n\t\tif (\n\t\t\tresponse.isSuccess &&\n\t\t\tresponse.data !== null &&\n\t\t\tresponse.data !== \"\"\n\t\t) {\n\t\t\tlet getUserUrlResponse = new GetUserUrlResponse().fromJson(\n\t\t\t\tresponse.data\n\t\t\t);\n\t\t\treturn new Response(true, response.message, getUserUrlResponse);\n\n\t\t\t// If data is retrieved and the data is empty, then return\n\t\t} else if (\n\t\t\tresponse.isSuccess &&\n\t\t\tresponse.message === \"No records found\"\n\t\t) {\n\t\t\treturn new Response(true, \"No records found\", \"\");\n\n\t\t\t// If http method is timeout or being halt, then return\n\t\t} else if (!response.isSuccess) {\n\t\t\treturn new Response(false, response.message, \"\");\n\t\t} else {\n\t\t\treturn new Response(false, response.message, response.data);\n\t\t}\n\t}\n\n\tasync getUrlById(value?: { urlId: string }): Promise<Response> {\n\t\tconst path = `urlId=${value?.urlId}`;\n\t\tlet response = await this.networking.getData(`get_url_by_id?${path}`);\n\t\t// If data is retrieved and the data is not empty, then return\n\t\tif (\n\t\t\tresponse.isSuccess &&\n\t\t\tresponse.data !== null &&\n\t\t\tresponse.data !== \"\"\n\t\t) {\n\t\t\tlet getUserUrlResponse = new GetUserUrlResponse().fromJson(\n\t\t\t\tresponse.data\n\t\t\t);\n\t\t\treturn new Response(true, response.message, getUserUrlResponse);\n\n\t\t\t// If data is retrieved and the data is empty, then return\n\t\t} else if (\n\t\t\tresponse.isSuccess &&\n\t\t\tresponse.message === \"No records found\"\n\t\t) {\n\t\t\treturn new Response(true, \"No records found\", \"\");\n\n\t\t\t// If http method is timeout or being halt, then return\n\t\t} else if (!response.isSuccess) {\n\t\t\treturn new Response(false, response.message, \"\");\n\t\t} else {\n\t\t\treturn new Response(false, response.message, response.data);\n\t\t}\n\t}\n\n\tasync getUrlByApiKey(value?: { apiKey: string }): Promise<Response> {\n\t\tconst path = `apiKey=${value?.apiKey}`;\n\t\tlet response = await this.networking.getData(\n\t\t\t`get_url_by_api_key?${path}`\n\t\t);\n\t\t// If data is retrieved and the data is not empty, then return\n\t\tif (\n\t\t\tresponse.isSuccess &&\n\t\t\tresponse.data !== null &&\n\t\t\tresponse.data !== \"\"\n\t\t) {\n\t\t\tlet getUserUrlResponse = new GetUserUrlResponse().fromJson(\n\t\t\t\tresponse.data\n\t\t\t);\n\t\t\treturn new Response(true, response.message, getUserUrlResponse);\n\n\t\t\t// If data is retrieved and the data is empty, then return\n\t\t} else if (\n\t\t\tresponse.isSuccess &&\n\t\t\tresponse.message === \"No records found\"\n\t\t) {\n\t\t\treturn new Response(true, \"No records found\", \"\");\n\n\t\t\t// If http method is timeout or being halt, then return\n\t\t} else if (!response.isSuccess) {\n\t\t\treturn new Response(false, response.message, \"\");\n\t\t} else {\n\t\t\treturn new Response(false, response.message, response.data);\n\t\t}\n\t}\n\n\tasync saveUrl(props: {\n\t\turlId?: string;\n\t\tuserId?: string;\n\t\tapiKey?: string;\n\t\turl?: string;\n\t\tschema?: Array<SchemaField>;\n\t\tconfigParam?: Array<ConfigParam>;\n\t}): Promise<Response> {\n\t\t// Initialize the save user model\n\t\tconst save_url = new UserUrl({\n\t\t\tuserId: props.userId,\n\t\t\tapiKey: props.apiKey,\n\t\t\turl: props.url,\n\t\t\tschema: props.schema,\n\t\t\tconfigParam: props.configParam,\n\t\t});\n\n\t\t// Object to Map, then to JSON\n\t\tconst body = Object.fromEntries(save_url.toJson());\n\n\t\tlet headers = {\n\t\t\t\"Content-Type\": \"application/json\",\n\t\t};\n\n\t\tlet response = await this.networking.postData(\n\t\t\t\"save_url\", // API choice is depends on the usage\n\t\t\tbody,\n\t\t\theaders\n\t\t);\n\n\t\t// If data is retrieved and the data is not empty, then return\n\t\tif (\n\t\t\tresponse.isSuccess &&\n\t\t\tresponse.data !== null &&\n\t\t\tresponse.data !== \"\"\n\t\t) {\n\t\t\treturn new Response(true, response.message, response.data);\n\n\t\t\t// If data is retrieved and the data is empty, then return\n\t\t} else if (\n\t\t\tresponse.isSuccess &&\n\t\t\tresponse.message === \"No records found\"\n\t\t) {\n\t\t\treturn new Response(true, \"No records found\", \"\");\n\n\t\t\t// If http method is timeout or being halt, then return\n\t\t} else if (!response.isSuccess) {\n\t\t\treturn new Response(false, response.message, \"\");\n\t\t} else {\n\t\t\treturn new Response(false, response.message, response.data);\n\t\t}\n\t}\n\n\tasync deleteUrl(props: { urlId?: string }): Promise<Response> {\n\t\t// Initialize the save user model\n\t\tconst delete_url = new UserUrl({\n\t\t\turlId: props.urlId,\n\t\t});\n\n\t\t// Object to Map, then to JSON\n\t\tconst body = Object.fromEntries(delete_url.toJson());\n\n\t\tlet response = await this.networking.deleteData(\n\t\t\t\"delete_url\", // API choice is depends on the usage\n\t\t\tbody\n\t\t);\n\n\t\t// If data is retrieved and the data is not empty, then return\n\t\tif (\n\t\t\tresponse.isSuccess &&\n\t\t\tresponse.data !== null &&\n\t\t\tresponse.data !== \"\"\n\t\t) {\n\t\t\treturn new Response(true, response.message, response.data);\n\n\t\t\t// If data is retrieved and the data is empty, then return\n\t\t} else if (\n\t\t\tresponse.isSuccess &&\n\t\t\tresponse.message === \"No records found\"\n\t\t) {\n\t\t\treturn new Response(true, \"No records found\", \"\");\n\n\t\t\t// If http method is timeout or being halt, then return\n\t\t} else if (!response.isSuccess) {\n\t\t\treturn new Response(false, response.message, \"\");\n\t\t} else {\n\t\t\treturn new Response(false, response.message, response.data);\n\t\t}\n\t}\n\n\tasync validateUrl(props: { url?: string }): Promise<Response> {\n\t\t// Initialize the save user model\n\t\tconst validate_url = new SchemaField({\n\t\t\turl: props.url,\n\t\t});\n\n\t\t// Object to Map, then to JSON\n\t\tconst body = Object.fromEntries(validate_url.toJson());\n\n\t\tlet headers = {\n\t\t\t\"Content-Type\": \"application/json\",\n\t\t};\n\n\t\tlet response = await this.networking.postData(\n\t\t\t\"validate_url\", // API choice is depends on the usage\n\t\t\tbody,\n\t\t\theaders\n\t\t);\n\n\t\t// If data is retrieved and the data is not empty, then return\n\t\tif (\n\t\t\tresponse.isSuccess &&\n\t\t\tresponse.data !== null &&\n\t\t\tresponse.data !== \"\"\n\t\t) {\n\t\t\tlet getSchemaFieldResponse = new GetSchemaFieldResponse().fromJson(\n\t\t\t\tresponse.data\n\t\t\t);\n\t\t\treturn new Response(true, response.message, getSchemaFieldResponse);\n\n\t\t\t// If data is retrieved and the data is empty, then return\n\t\t} else if (\n\t\t\tresponse.isSuccess &&\n\t\t\tresponse.message === \"No records found\"\n\t\t) {\n\t\t\treturn new Response(true, \"No records found\", \"\");\n\n\t\t\t// If http method is timeout or being halt, then return\n\t\t} else if (!response.isSuccess) {\n\t\t\treturn new Response(false, response.message, \"\");\n\t\t} else {\n\t\t\treturn new Response(false, response.message, response.data);\n\t\t}\n\t}\n\n\tasync getSchemaByApiKey(value?: { apiKey: string }): Promise<Response> {\n\t\tconst path = `apiKey=${value?.apiKey}`;\n\t\tlet response = await this.networking.getData(\n\t\t\t`get_schema_field?${path}`\n\t\t);\n\t\t// If data is retrieved and the data is not empty, then return\n\t\tif (\n\t\t\tresponse.isSuccess &&\n\t\t\tresponse.data !== null &&\n\t\t\tresponse.data !== \"\"\n\t\t) {\n\t\t\tlet getSchemaFieldResponse = new GetSchemaFieldResponse().fromJson(\n\t\t\t\tresponse.data\n\t\t\t);\n\t\t\treturn new Response(true, response.message, getSchemaFieldResponse);\n\n\t\t\t// If data is retrieved and the data is empty, then return\n\t\t} else if (\n\t\t\tresponse.isSuccess &&\n\t\t\tresponse.message === \"No records found\"\n\t\t) {\n\t\t\treturn new Response(true, \"No records found\", \"\");\n\n\t\t\t// If http method is timeout or being halt, then return\n\t\t} else if (!response.isSuccess) {\n\t\t\treturn new Response(false, response.message, \"\");\n\t\t} else {\n\t\t\treturn new Response(false, response.message, response.data);\n\t\t}\n\t}\n\n\tasync getConfigParamByApiKey(value?: {\n\t\tapiKey: string;\n\t}): Promise<Response> {\n\t\tconst path = `apiKey=${value?.apiKey}`;\n\t\tlet response = await this.networking.getData(\n\t\t\t`get_config_param_by_api_key?${path}`\n\t\t);\n\t\t// If data is retrieved and the data is not empty, then return\n\t\tif (\n\t\t\tresponse.isSuccess &&\n\t\t\tresponse.data !== null &&\n\t\t\tresponse.data !== \"\"\n\t\t) {\n\t\t\tlet getConfigParamResponse = new GetConfigParamResponse().fromJson(\n\t\t\t\tresponse.data\n\t\t\t);\n\t\t\treturn new Response(true, response.message, getConfigParamResponse);\n\n\t\t\t// If data is retrieved and the data is empty, then return\n\t\t} else if (\n\t\t\tresponse.isSuccess &&\n\t\t\tresponse.message === \"No records found\"\n\t\t) {\n\t\t\treturn new Response(true, \"No records found\", \"\");\n\n\t\t\t// If http method is timeout or being halt, then return\n\t\t} else if (!response.isSuccess) {\n\t\t\treturn new Response(false, response.message, \"\");\n\t\t} else {\n\t\t\treturn new Response(false, response.message, response.data);\n\t\t}\n\t}\n\n\tasync getDataRowsByApiKey(value?: {\n\t\tuserApiId: string;\n\t\tapiKey: string;\n\t\tdimensionArray?: Array<string>;\n\t\tmetricsArray?: Array<string>;\n\t}): Promise<Response> {\n\t\tconst path = `userApiId=${value?.userApiId}&apiKey=${\n\t\t\tvalue?.apiKey\n\t\t}&dimensionArray=${JSON.stringify(\n\t\t\tvalue?.dimensionArray\n\t\t)}&metricsArray=${JSON.stringify(value?.metricsArray)}`;\n\t\tlet response = await this.networking.getData(`generate_data?${path}`);\n\t\t// If data is retrieved and the data is not empty, then return\n\t\tif (\n\t\t\tresponse.isSuccess &&\n\t\t\tresponse.data !== null &&\n\t\t\tresponse.data !== \"\"\n\t\t) {\n\t\t\tlet getDataRowsByApiKey = new GetDataRowsResponse().fromJson(\n\t\t\t\tresponse.data\n\t\t\t);\n\t\t\treturn new Response(true, response.message, getDataRowsByApiKey);\n\n\t\t\t// If data is retrieved and the data is empty, then return\n\t\t} else if (\n\t\t\tresponse.isSuccess &&\n\t\t\tresponse.message === \"No records found\"\n\t\t) {\n\t\t\treturn new Response(true, \"No records found\", \"\");\n\n\t\t\t// If http method is timeout or being halt, then return\n\t\t} else if (!response.isSuccess) {\n\t\t\treturn new Response(false, response.message, \"\");\n\t\t} else {\n\t\t\treturn new Response(false, response.message, response.data);\n\t\t}\n\t}\n\n\tasync generateDataResponse(props: {\n\t\tuserApiId?: string;\n\t\tapiKey?: string;\n\t\tdimensionArray?: Array<string>;\n\t\tmetricsArray?: Array<string>;\n\t\tmetricsOperation?: Array<string>;\n\t}): Promise<Response> {\n\t\t// Initialize the save user model\n\t\tconst generate_data = new DataRows({\n\t\t\tuserApiId: props.userApiId,\n\t\t\tapiKey: props.apiKey,\n\t\t\tdimensionArray: props.dimensionArray,\n\t\t\tmetricsArray: props.metricsArray,\n\t\t\tmetricsOperation: props.metricsOperation,\n\t\t});\n\n\t\t// Object to Map, then to JSON\n\t\tconst body = Object.fromEntries(generate_data.toJson());\n\n\t\tlet headers = {\n\t\t\t\"Content-Type\": \"application/json\",\n\t\t};\n\n\t\tlet response = await this.networking.postData(\n\t\t\t\"generate_data\", // API choice is depends on the usage\n\t\t\tbody,\n\t\t\theaders\n\t\t);\n\n\t\t// If data is retrieved and the data is not empty, then return\n\t\tif (\n\t\t\tresponse.isSuccess &&\n\t\t\tresponse.data !== null &&\n\t\t\tresponse.data !== \"\"\n\t\t) {\n\t\t\tlet getSchemaFieldResponse = new GetDataRowsResponse().fromJson(\n\t\t\t\tresponse.data\n\t\t\t);\n\t\t\treturn new Response(true, response.message, getSchemaFieldResponse);\n\n\t\t\t// If data is retrieved and the data is empty, then return\n\t\t} else if (\n\t\t\tresponse.isSuccess &&\n\t\t\tresponse.message === \"No records found\"\n\t\t) {\n\t\t\treturn new Response(true, \"No records found\", \"\");\n\n\t\t\t// If http method is timeout or being halt, then return\n\t\t} else if (!response.isSuccess) {\n\t\t\treturn new Response(false, response.message, \"\");\n\t\t} else {\n\t\t\treturn new Response(false, response.message, response.data);\n\t\t}\n\t}\n\n\tasync saveGraph(props: {\n\t\tuserApiId: string;\n\t\tapiKey: string;\n\t\tlayouts: Array<any>;\n\t\tgraphs: Array<{\n\t\t\tdimension_array: Array<any>;\n\t\t\tmetrics_operation_array: Array<any>;\n\t\t\tdata_grid: Array<any>;\n\t\t}>;\n\t}): Promise<Response> {\n\t\t// Initialize the save user model\n\t\tconst save_graph = new Graphs({\n\t\t\tuserApiId: props.userApiId,\n\t\t\tapiKey: props.apiKey,\n\t\t\tlayouts: props.layouts,\n\t\t\tgraphs: props.graphs,\n\t\t});\n\n\t\t// Object to Map, then to JSON\n\t\tconst body = Object.fromEntries(save_graph.toJson());\n\n\t\tlet headers = {\n\t\t\t\"Content-Type\": \"application/json\",\n\t\t};\n\n\t\tlet response = await this.networking.postData(\n\t\t\t\"save_graph\", // API choice is depends on the usage\n\t\t\tbody,\n\t\t\theaders\n\t\t);\n\n\t\t// If data is retrieved and the data is not empty, then return\n\t\tif (\n\t\t\tresponse.isSuccess &&\n\t\t\tresponse.data !== null &&\n\t\t\tresponse.data !== \"\"\n\t\t) {\n\t\t\treturn new Response(true, response.message, true);\n\n\t\t\t// If data is retrieved and the data is empty, then return\n\t\t} else if (\n\t\t\tresponse.isSuccess &&\n\t\t\tresponse.message === \"No records found\"\n\t\t) {\n\t\t\treturn new Response(true, \"No records found\", \"\");\n\n\t\t\t// If http method is timeout or being halt, then return\n\t\t} else if (!response.isSuccess) {\n\t\t\treturn new Response(false, response.message, \"\");\n\t\t} else {\n\t\t\treturn new Response(false, response.message, response.data);\n\t\t}\n\t}\n\n\tasync getGraphsByApiKey(value?: { apiKey: string }): Promise<Response> {\n\t\tconst path = `apiKey=${value?.apiKey}`;\n\t\tlet response = await this.networking.getData(`get_graph_by_api_key?${path}`);\n\t\t// If data is retrieved and the data is not empty, then return\n\t\tif (\n\t\t\tresponse.isSuccess &&\n\t\t\tresponse.data !== null &&\n\t\t\tresponse.data !== \"\"\n\t\t) {\n\t\t\tlet getDataRowsByApiKey = new GetDataRowsResponse().fromJson(\n\t\t\t\tresponse.data\n\t\t\t);\n\t\t\treturn new Response(true, response.message, getDataRowsByApiKey);\n\n\t\t\t// If data is retrieved and the data is empty, then return\n\t\t} else if (\n\t\t\tresponse.isSuccess &&\n\t\t\tresponse.message === \"No records found\"\n\t\t) {\n\t\t\treturn new Response(true, \"No records found\", \"\");\n\n\t\t\t// If http method is timeout or being halt, then return\n\t\t} else if (!response.isSuccess) {\n\t\t\treturn new Response(false, response.message, \"\");\n\t\t} else {\n\t\t\treturn new Response(false, response.message, response.data);\n\t\t}\n\t}\n\n\tasync getGraphsWithParamByApiKey(value?: { apiKey: string }): Promise<Response> {\n\t\tconst path = `apiKey=${value?.apiKey}`;\n\t\tlet response = await this.networking.getData(`get_graph_with_param_by_api_key?${path}`);\n\t\t// If data is retrieved and the data is not empty, then return\n\t\tif (\n\t\t\tresponse.isSuccess &&\n\t\t\tresponse.data !== null &&\n\t\t\tresponse.data !== \"\"\n\t\t) {\n\t\t\tlet getDataRowsByApiKey = new GetDataRowsResponse().fromJson(\n\t\t\t\tresponse.data\n\t\t\t);\n\t\t\treturn new Response(true, response.message, getDataRowsByApiKey);\n\n\t\t\t// If data is retrieved and the data is empty, then return\n\t\t} else if (\n\t\t\tresponse.isSuccess &&\n\t\t\tresponse.message === \"No records found\"\n\t\t) {\n\t\t\treturn new Response(true, \"No records found\", \"\");\n\n\t\t\t// If http method is timeout or being halt, then return\n\t\t} else if (!response.isSuccess) {\n\t\t\treturn new Response(false, response.message, \"\");\n\t\t} else {\n\t\t\treturn new Response(false, response.message, response.data);\n\t\t}\n\t}\n}\n"]},"metadata":{},"sourceType":"module"}