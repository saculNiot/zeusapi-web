{"ast":null,"code":"import { LocalStorage } from \"../../../utils/localStorage\";\nimport { Networking } from \"../../networking\";\nimport { Response } from \"../../response\";\nimport { GetRoleResponse, Role } from \"../models/role_model\";\nexport class RoleRepo {\n  constructor() {\n    this.networking = new Networking();\n  }\n\n  async getAllRoles(value) {\n    const path = `userId=${value === null || value === void 0 ? void 0 : value.userId}`;\n    let headers = {\n      Authorization: `Bearer ${await LocalStorage.getAccessToken()}`\n    };\n    let response = await this.networking.getData(`get_all_role_by_createdby_id?${path}`, headers); // If data is retrieved and the data is not empty, then return\n\n    if (response.isSuccess && response.data !== null && response.data !== \"\") {\n      let getRoleResponse = new GetRoleResponse().fromJson(response.data);\n      return new Response(true, response.message, getRoleResponse); // If data is retrieved and the data is empty, then return\n    } else if (response.isSuccess && response.message === \"No records found\") {\n      return new Response(true, \"No records found\", \"\"); // If http method is timeout or being halt, then return\n    } else if (!response.isSuccess) {\n      return new Response(false, response.message, \"\");\n    } else {\n      return new Response(false, response.message, response.data);\n    }\n  }\n\n  async getRoleById(value) {\n    const path = `roleId=${value === null || value === void 0 ? void 0 : value.roleId}`;\n    let headers = {\n      Authorization: `Bearer ${await LocalStorage.getAccessToken()}`\n    };\n    let response = await this.networking.getData(`get_role_by_id?${path}`, headers); // If data is retrieved and the data is not empty, then return\n\n    if (response.isSuccess && response.data !== null && response.data !== \"\") {\n      let getRoleResponse = new GetRoleResponse().fromJson(response.data);\n      return new Response(true, response.message, getRoleResponse); // If data is retrieved and the data is empty, then return\n    } else if (response.isSuccess && response.message === \"No records found\") {\n      return new Response(true, \"No records found\", \"\"); // If http method is timeout or being halt, then return\n    } else if (!response.isSuccess) {\n      return new Response(false, response.message, \"\");\n    } else {\n      return new Response(false, response.message, response.data);\n    }\n  }\n\n  async saveRole(props) {\n    // Initialize the save user model\n    const saveRole = new Role({\n      createdById: props.createdById,\n      roleId: props.roleId,\n      name: props.name\n    }); // Object to Map, then to JSON\n\n    const body = Object.fromEntries(saveRole.toJson());\n    let headers = {\n      \"Content-Type\": \"application/json\",\n      Authorization: `Bearer ${await LocalStorage.getAccessToken()}`\n    };\n    let response = await this.networking.postData(\"save_role\", // API choice is depends on the usage\n    body, headers); // If data is retrieved and the data is not empty, then return\n\n    if (response.isSuccess && response.data !== null && response.data !== \"\") {\n      return new Response(true, response.message, response.data); // If data is retrieved and the data is empty, then return\n    } else if (response.isSuccess && response.message === \"No records found\") {\n      return new Response(true, \"No records found\", \"\"); // If http method is timeout or being halt, then return\n    } else if (!response.isSuccess) {\n      return new Response(false, response.message, \"\");\n    } else {\n      return new Response(false, response.message, response.data);\n    }\n  }\n\n  async deleteRole(props) {\n    // Initialize the save user model\n    const delete_role = new Role({\n      roleId: props.roleId\n    }); // Object to Map, then to JSON\n\n    const body = Object.fromEntries(delete_role.toJson());\n    let headers = {\n      \"Content-Type\": \"application/json\",\n      Authorization: `Bearer ${await LocalStorage.getAccessToken()}`\n    };\n    let response = await this.networking.deleteData(\"delete_role\", // API choice is depends on the usage\n    body, headers); // If data is retrieved and the data is not empty, then return\n\n    if (response.isSuccess && response.data !== null && response.data !== \"\") {\n      return new Response(true, response.message, response.data); // If data is retrieved and the data is empty, then return\n    } else if (response.isSuccess && response.message === \"No records found\") {\n      return new Response(true, \"No records found\", \"\"); // If http method is timeout or being halt, then return\n    } else if (!response.isSuccess) {\n      return new Response(false, response.message, \"\");\n    } else {\n      return new Response(false, response.message, response.data);\n    }\n  }\n\n}","map":{"version":3,"sources":["/Users/gohshengyang/Documents/GitHub/zeusapi-web/src/services/api/repositories/role_repo.tsx"],"names":["LocalStorage","Networking","Response","GetRoleResponse","Role","RoleRepo","networking","getAllRoles","value","path","userId","headers","Authorization","getAccessToken","response","getData","isSuccess","data","getRoleResponse","fromJson","message","getRoleById","roleId","saveRole","props","createdById","name","body","Object","fromEntries","toJson","postData","deleteRole","delete_role","deleteData"],"mappings":"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","sourcesContent":["import { LocalStorage } from \"../../../utils/localStorage\";\nimport { Networking } from \"../../networking\";\nimport { Response } from \"../../response\";\nimport { GetRoleResponse, Role } from \"../models/role_model\";\n\nexport class RoleRepo {\n\tnetworking = new Networking();\n\n\tasync getAllRoles(value?: { userId: string }): Promise<Response> {\n\t\tconst path = `userId=${value?.userId}`;\n\t\tlet headers = {\n\t\t\tAuthorization: `Bearer ${await LocalStorage.getAccessToken()}`,\n\t\t};\n\t\tlet response = await this.networking.getData(\n\t\t\t`get_all_role_by_createdby_id?${path}`,\n\t\t\theaders\n\t\t);\n\t\t// If data is retrieved and the data is not empty, then return\n\t\tif (\n\t\t\tresponse.isSuccess &&\n\t\t\tresponse.data !== null &&\n\t\t\tresponse.data !== \"\"\n\t\t) {\n\t\t\tlet getRoleResponse = new GetRoleResponse().fromJson(\n\t\t\t\tresponse.data\n\t\t\t);\n\t\t\treturn new Response(true, response.message, getRoleResponse);\n\n\t\t\t// If data is retrieved and the data is empty, then return\n\t\t} else if (\n\t\t\tresponse.isSuccess &&\n\t\t\tresponse.message === \"No records found\"\n\t\t) {\n\t\t\treturn new Response(true, \"No records found\", \"\");\n\n\t\t\t// If http method is timeout or being halt, then return\n\t\t} else if (!response.isSuccess) {\n\t\t\treturn new Response(false, response.message, \"\");\n\t\t} else {\n\t\t\treturn new Response(false, response.message, response.data);\n\t\t}\n\t}\n\n\tasync getRoleById(value?: { roleId: string }): Promise<Response> {\n\t\tconst path = `roleId=${value?.roleId}`;\n\t\tlet headers = {\n\t\t\tAuthorization: `Bearer ${await LocalStorage.getAccessToken()}`,\n\t\t};\n\t\tlet response = await this.networking.getData(\n\t\t\t`get_role_by_id?${path}`,\n\t\t\theaders\n\t\t);\n\t\t// If data is retrieved and the data is not empty, then return\n\t\tif (\n\t\t\tresponse.isSuccess &&\n\t\t\tresponse.data !== null &&\n\t\t\tresponse.data !== \"\"\n\t\t) {\n\t\t\tlet getRoleResponse = new GetRoleResponse().fromJson(\n\t\t\t\tresponse.data\n\t\t\t);\n\t\t\treturn new Response(true, response.message, getRoleResponse);\n\n\t\t\t// If data is retrieved and the data is empty, then return\n\t\t} else if (\n\t\t\tresponse.isSuccess &&\n\t\t\tresponse.message === \"No records found\"\n\t\t) {\n\t\t\treturn new Response(true, \"No records found\", \"\");\n\n\t\t\t// If http method is timeout or being halt, then return\n\t\t} else if (!response.isSuccess) {\n\t\t\treturn new Response(false, response.message, \"\");\n\t\t} else {\n\t\t\treturn new Response(false, response.message, response.data);\n\t\t}\n\t}\n\n\tasync saveRole(props: {\n\t\tcreatedById?:string;\n\t\troleId?: string;\n\t\tname?: string;\n\t}): Promise<Response> {\n\t\t// Initialize the save user model\n\t\tconst saveRole = new Role({\n\t\t\tcreatedById: props.createdById,\n\t\t\troleId: props.roleId,\n\t\t\tname: props.name,\n\t\t});\n\n\t\t// Object to Map, then to JSON\n\t\tconst body = Object.fromEntries(saveRole.toJson());\n\n\t\tlet headers = {\n\t\t\t\"Content-Type\": \"application/json\",\n\t\t\tAuthorization: `Bearer ${await LocalStorage.getAccessToken()}`,\n\t\t};\n\n\t\tlet response = await this.networking.postData(\n\t\t\t\"save_role\", // API choice is depends on the usage\n\t\t\tbody,\n\t\t\theaders\n\t\t);\n\n\t\t// If data is retrieved and the data is not empty, then return\n\t\tif (\n\t\t\tresponse.isSuccess &&\n\t\t\tresponse.data !== null &&\n\t\t\tresponse.data !== \"\"\n\t\t) {\n\t\t\treturn new Response(true, response.message, response.data);\n\n\t\t\t// If data is retrieved and the data is empty, then return\n\t\t} else if (\n\t\t\tresponse.isSuccess &&\n\t\t\tresponse.message === \"No records found\"\n\t\t) {\n\t\t\treturn new Response(true, \"No records found\", \"\");\n\n\t\t\t// If http method is timeout or being halt, then return\n\t\t} else if (!response.isSuccess) {\n\t\t\treturn new Response(false, response.message, \"\");\n\t\t} else {\n\t\t\treturn new Response(false, response.message, response.data);\n\t\t}\n\t}\n\n    async deleteRole(props: { roleId?: string }): Promise<Response> {\n\t\t// Initialize the save user model\n\t\tconst delete_role = new Role({\n\t\t\troleId: props.roleId,\n\t\t});\n\n\t\t// Object to Map, then to JSON\n\t\tconst body = Object.fromEntries(delete_role.toJson());\n\n        let headers = {\n\t\t\t\"Content-Type\": \"application/json\",\n\t\t\tAuthorization: `Bearer ${await LocalStorage.getAccessToken()}`,\n\t\t};\n\n\n\t\tlet response = await this.networking.deleteData(\n\t\t\t\"delete_role\", // API choice is depends on the usage\n\t\t\tbody,\n            headers\n\t\t);\n\n\t\t// If data is retrieved and the data is not empty, then return\n\t\tif (\n\t\t\tresponse.isSuccess &&\n\t\t\tresponse.data !== null &&\n\t\t\tresponse.data !== \"\"\n\t\t) {\n\t\t\treturn new Response(true, response.message, response.data);\n\n\t\t\t// If data is retrieved and the data is empty, then return\n\t\t} else if (\n\t\t\tresponse.isSuccess &&\n\t\t\tresponse.message === \"No records found\"\n\t\t) {\n\t\t\treturn new Response(true, \"No records found\", \"\");\n\n\t\t\t// If http method is timeout or being halt, then return\n\t\t} else if (!response.isSuccess) {\n\t\t\treturn new Response(false, response.message, \"\");\n\t\t} else {\n\t\t\treturn new Response(false, response.message, response.data);\n\t\t}\n\t}\n}\n"]},"metadata":{},"sourceType":"module"}